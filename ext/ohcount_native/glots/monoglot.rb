require 'escape_helper'

module Ohcount
	# ==== Monoglots and Polyglots
	#
	# The source code parser is written in C. However, you will not write any C code to add
	# a language to Ohcount. The C code is generated by another bit of code called a Monoglot or
	# Polyglot, written in Ruby.
	#
	# At build time, Generator.generate will be run, which loads all Monoglots and
	# Polyglots to generate the C file polyglots.c.
	#
	# The parser for a single language is generated by a Monoglot.
	#
	# A Polyglot generates a parser for file formats that span several languages.
	#
	# ==== Creating a New Monoglot
	#
	# You may not need to create a fully custom Monoglot. If your language has a simple syntax,
	# you may be able to use the CMonoglot. This is a flexible Monoglot that can generate
	# parsers for most C-like languages. In fact, most of the parsers in ohcount are examples
	# of CMonoglot, and you can see examples in Generator.
	#
	# If you do need to create a custom Monoglot, you must create a new Ruby class that
	# derives from Ohcount::Monoglot, and save it in <tt>ext/ohcount_native/glots</tt>.
	#
	# A Monoglot is simply an array of states and an array of transitions between those
	# states. When creating your own Monoglot, you can define as many states and transitions
	# as you require. The parser will be initialized in the first state listed.
	#
	# As the source code is scanned, tokens which match those defined in the transitions
	# will cause the parser will advance to a new state. Each state is associated with
	# either code, comments, or blanks, so as the state machine advances through the source code,
	# the source code will be categorized accordingly.
	#
	# Whenever you define a new language, you must update
	# Ohcount::Generator, which maintains the master list of all known langauges.
	class Monoglot
		include EscapeHelper

		# The name must be unique
		attr_reader :name

		# A collection of State objects representing possible states
		attr_reader :states

		# The Transition objects defining transitions between states
		attr_reader :transitions

		def initialize(name, states = [], transitions = [])
			@name = name
			@states = states
			@transitions = transitions
		end

		# Emit the generated C code for the state machine definition.
		def print(io)
			Monoglot::print_banner(io, name)
			print_states(io)
			print_transitions(io)
			print_polyglot_def(io)
		end

		def self.print_banner(io, name)
			io.puts ""
			io.puts "/*****************************************************************************"
			left = (80 - name.size)/2
			io.write " "*left
			io.puts name
			io.puts "*****************************************************************************/"
		end

		def definition
		"#{ @name.upcase }_POLYGLOT"
		end
		protected

		def print_states(io)
			#define each
			io.puts "/* States */"
			@states.each do |s|
				s.print(io)
			end

			# now define the collection
			io.write "State *#{ name.upcase }_STATES[] = { "
			@states.each do |s|
				io.write "&#{ s.definition }, "
			end
			io.write "NULL };\n"
		end

		def print_transitions(io)
			io.puts "/* Transitions */"
			# print each transition
			@transitions.each do |t|
				t.print(io)
			end

			#aggregate the transitions
			io.write  "Transition *#{ name.upcase }_TRANSITIONS[] = {"
			@transitions.each do |t|
				io.write " &#{ t.definition },"
			end
			io.write " NULL};\n"
		end

		def print_polyglot_def(io)
			io.puts <<LANG_DEF
Polyglot #{ definition } = {
	"#{ @name.downcase }",
			#{ @name.upcase }_STATES,
			#{ @name.upcase }_TRANSITIONS,
	NULL
};
LANG_DEF
		end

	end
end
